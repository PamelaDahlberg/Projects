Chapter 4
how do we express a program as a set of cooperating parts and how can they share and exchange data

Our job as programmers is to express computations
• Correctly
• Simply
• Efficiently

When programming is done well, such concerns minimize the need for the most frustrating part of programming:
debugging

good program structure during development can minimize the number of mistakes made and the time needed
to search for such errors and to remove them

Our main tool for organizing a program — and for organizing our thoughts as we program — is to break up a big
computation into many little ones. This technique comes in two variations:
• Abstraction: Hide details that we don’t need to use a facility (“implementation details”) behind a convenient and general
interface. For example, rather than considering the details of how to sort a phone book (thick books have been written
about how to sort), we just call the sort algorithm from the C++ standard library. All we need to know to sort is how to
invoke (call) that algorithm, so we can write sort(b) where b refers to the phone book; sort() is a variant (§21.9) of the
standard library sort algorithm (§21.8, §B.5.4) defined in std_library.h. Another example is the way we use computer
memory. Direct use of memory can be quite messy, so we access it through typed and named variables (§3.2), standard
library vectors (§4.6, Chapters 17–19), maps (Chapter 21), etc.
• “Divide and conquer”: Here we take a large problem and divide it into several little ones. For example, if we need to
build a dictionary, we can separate that job into three: read the data, sort the data, and output the data. Each of the
resulting problems is significantly smaller than the original.


constexpr must be defined at time of compile
const must be defined and then not changed after initialization